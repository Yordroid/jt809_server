package util

import (
	"errors"
	"fmt"
	"io"
)

type Scanner struct {
	r          io.Reader
	split      SplitFunc // The function to split the tokens.
	token      []byte    // Last token returned by split.
	buf        []byte    // Buffer used as argument to split.
	start      int       // First non-processed byte in buf.
	end        int       // End of data in buf.
	err        error     // Sticky error.
	maxBufSize int
	isScan     bool
}

// Errors returned by Scanner.
var (
	ErrTooShort        = errors.New("util.Scanner: token too short")
	ErrTooLong         = errors.New("util.Scanner: token too long")
	ErrNegativeAdvance = errors.New("util.Scanner: SplitFunc returns negative advance count")
	ErrAdvanceTooFar   = errors.New("util.Scanner: SplitFunc returns advance count beyond input")
	ErrBadReadCount    = errors.New("util.Scanner: Read returned impossible count")
	ErrNotCallScan     = errors.New("util.Scanner: Before call Next() need call Scan()")
)

const VS_READ_BUF_MAX_SIZE = 10 * 1024
const VS_READ_BUF_FRAME_MAX_SIZE = 1 * 1024

type SplitFunc func(data []byte) (advance int, token []byte, err error)

// NewScanner returns a new Scanner to read from r.
// The split function defaults to ScanLines.
func NewScanner(r io.Reader) *Scanner {
	return &Scanner{
		r:          r,
		split:      nil,
		buf:        make([]byte, VS_READ_BUF_MAX_SIZE+VS_READ_BUF_FRAME_MAX_SIZE),
		maxBufSize: VS_READ_BUF_MAX_SIZE,
	}
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == io.EOF {
		return nil
	}
	return s.err
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	return string(s.token)
}

func (s *Scanner) Scan() bool {
	s.readDataFromBuf()
	if s.split == nil {
		return false
	}
	s.isScan = true
	return true
}
func (s *Scanner) CloseScan() {
	s.isScan = false
}
func (s *Scanner) Next() bool {
	if !s.isScan {
		s.setErr(ErrNotCallScan)
		return false
	}
	if s.end > s.maxBufSize {
		fmt.Println("ytr")
	}
	if s.end > s.maxBufSize && s.start > s.maxBufSize {
		if s.start == s.end {
			s.end = 0
			s.start = 0
		} else if s.start < s.end {
			copy(s.buf, s.buf[s.start:s.end])
			s.end -= s.start
			s.start = 0
		}

	}
	if s.end == s.start && s.start == s.maxBufSize {
		s.end = 0
		s.start = 0
	}
	if s.end > s.start {
		advance, token, err := s.split(s.buf[s.start:s.end])
		if err != nil {
			//需要跳过
			if advance > 0 {
				s.start += advance
				return true
			}
			if advance == -1 || advance > s.end {
				s.start = 0
				s.end = 0
				s.setErr(ErrNegativeAdvance)
			}
			return false
		}

		//数据不足
		if advance == 0 {
			copy(s.buf, s.buf[s.start:s.end])
			s.end -= s.start
			s.start = 0
			s.setErr(ErrTooShort)
			return false
		}
		s.token = token
		s.start += advance
		return true
	}
	return false
}

// Split panics if it is called after scanning has started.
func (s *Scanner) Split(split SplitFunc) {
	s.split = split
}

func (s *Scanner) readDataFromBuf() {
	var readBuf [VS_READ_BUF_FRAME_MAX_SIZE]byte

	for {
		if s.end >= s.maxBufSize {
			break
		}
		n, err := s.r.Read(readBuf[:])
		if err != nil || n == 0 {
			break
		}
		copy(s.buf[s.end:], readBuf[:n])
		s.end += n
	}
}

// advance consumes n bytes of the buffer. It reports whether the advance was legal.
func (s *Scanner) advance(n int) bool {
	if n < 0 {
		s.setErr(ErrNegativeAdvance)
		return false
	}
	if n > s.end-s.start {
		s.setErr(ErrAdvanceTooFar)
		return false
	}
	s.start += n
	return true
}

// setErr records the first error encountered.
func (s *Scanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}
